[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/GV_k7ho0)
სახელი და გვარი: ზურაბ შაყულაშვილი 
ფრიუნის იმეილი: zshak20@freeuni.edu.ge

# მესამე დავალების ინსტრუქცია

ეს დავალება შედგება ორი ნაწილისგან. ორივე ნაწილის კოდი შეგიძლიათ დაწეროთ მოდულარულად, მთავარია ყველა ფაილი, რომელიც გაშვებისთვის იქნება საჭირო, ატვირთოთ აქ. საწყისი კოდი მოცემულია Python3-ზე. შესაბამისად, უნდა დაწეროთ ამ ენაზე. 

_ამ დავალებებში **არ შეგიძლიათ** გარე ბიბლიოთეკების გამოყენება_

### ამოცანა 1 - Meet-in-the-middle შეტევა დისკრეტულ ლოგარითმზე (50 ქულა)

ამ ამოცანაში თქვენ უნდა გამოთვალოთ დისკრეტული ლოგარითმი Z<sub>p</sub><sup>*</sup>-ში, სადაც p არის მარტივი რიცხვი. გადმოგეცემათ ოთხი არგუმენტი:

+ p - მარტივი რიცხვი,
+ g - Z<sub>p</sub><sup>*</sup>-ის გენერატორი,
+ h - Z<sub>p</sub><sup>*</sup>-ის ერთ-ერთი ელემენტი; დააკვირდით, რომ არსებობს ისეთი x რომ h ≡ g<sup>x</sup> (mod p),
+ max_x - x-ის მაქსიმალური მნიშვნელობა.

თქვენ უნდა იპოვოთ ის x, რომლისთვისაც სრულდება ტოლობა h ≡ g<sup>x</sup> (mod p).

მაგალითისთვის, რომელზეც შემოწმდება თქვენი კოდი, ცნობილია, რომ max_x არ აღემატება 2<sup>40</sup>-ს. ტრივიალური ალგორითმით (x-ის ყველა შესაძლო მნიშვნელობისთვის გადაყოლით) მოგვიწევდა 2<sup>40</sup> გამრავლების ჩატარება. მაგრამ ამ შემთხვევისთვის გამოვიყენებთ უფრო სწრაფ შეტევას - meet-in-the-middle attack-ს.

იმისთვის, რომ გავიგოთ, როგორ მუშაობს ეს შეტევა, შევნიშნოთ:

თუ max_x = B<sup>2</sup> და x ≤ B<sup>2</sup>, x შეგვიძლია წარმოვადგინოთ როგორც x = x<sub>0</sub>B + x<sub>1</sub>, სადაც x<sub>0</sub> ≤ B და x<sub>1</sub> ≤ B.

აქედან გამომდინარე, h ≡ g<sup>x</sup> ≡ g<sup>x<sub>0</sub>B + x<sub>1</sub></sup> ≡ g<sup>x<sub>0</sub>B</sup> ⋅ g<sup>x<sub>1</sub></sup> (mod p).
განტოლების ორივე მხარე შეგვიძლია გავყოთ g<sup>x<sub>1</sub></sup>-ზე და მივიღებთ:

h/g<sup>x<sub>1</sub></sup> ≡ (g<sup>B</sup>)<sup>x<sub>0</sub></sup> (mod p)

მიღებულ განტოლებაში ცნობილია ყველა ცვლადის მნიშვნელობა, გარდა x<sub>0</sub>-ისა და x<sub>1</sub>-ისა. ამიტომაც შეგვიძლია გამოვთვალოთ მარცხენა მხარის ყველა შესაძლო მნიშვნელობა, შევინახოთ ჰეშ-ცხრილში შესაბამის x<sub>1</sub>-თან ერთად და შემდეგ შევამოწმოთ, x<sub>0</sub>-ის რომელი მნიშვნელობისთვის გვექნება ჰეშ-ცხრილში (g<sup>B</sup>)<sup>x<sub>0</sub></sup>-ის შესაბამისი ჩანაწერი. 

(დაახლოებით რამდენი ოპერაცია დაგვჭირდება ამ შეტევის განსახორციელებლად?)

#### ტექნიკური დეტალები:

თქვენ უნდა შეავსოთ ფაილი `dlog.py` (დაწეროთ `discrete_log` ფუნქციის იმპლემენტაცია), რომელიც გაიშვება შემდეგი ბრძანებით:
```
python3 dlog.py
```

stdin-დან შემოვა p-ს, g-ს და h-ის მნიშვნელობები.
stdout-ზე უნდა გამოიტანოთ x-ის მნიშვნელობა. 

თუ თქვენი კოდი **1 წუთში** არ დაასრულებს მუშაობას, ქულას ვერ მიიღებთ.

ტერმინალში პროგრამის მუშაობის დრო შეგიძლიათ შეამოწმოთ time ბრძანების გამოყენებით.

<br>

### ამოცანა 2 - RSA-ზე დაფუძნებული ხელმოწერის გაყალბება (50 ქულა)
63-ბაიტინი შეტყობინებებისთვის ხელმოწერის დასაგენერირებლად იყენებენ შემდეგ სქემას: საჯარო გასაღები არის RSA-ის სტანდარტული წყვილი (N,e), საიდუმლო გასაღები კი, ასევე სტანდარტულად - (N,d), სადაც N არის 128-ბაიტიანი (1024-ბიტიანი) მთელი რიცხვი. 63-ბაიტიანი შეტყობინება m-ის ხელმოწერა კი გამოითვლება ასე: σ ≡ M<sup>d</sup>(mod N), სადაც:

M = 0x00 m 0x00 m
(დარწმუნდით, რომ M-ის ზომა 128 ბაიტია).

თუკი m-ის ზომა ნაკლებია 63 ბაიტზე, მაშინ შეტყობინებას წინ ემატება 0-ები საჭირო ზომამდე შესავსებად (ერთბაიტიან შეტყობინება “x”-სა და ორბაიტიან შეტყობინება “0x00 x”-ს ერთნაირი ხელმოწერა ექნებათ. სქემის ეს სისუსტე ცნობილია და არ არის საინტერესო ამ ამოცანაში).

თქვენი ამოცანაა, იპოვოთ ხელმოწერა 63-ბაიტიანი challenge შეტყობინებისთვის.

თქვენ გექნებათ წვდომა სერვერთან, რომელიც დაგიბრუნებთ ნებისმიერი 63-ბაიტიანი ან უფრო მოკლე შეტყობინების ხელმოწერას, გარდა challenge შეტყობინებისა.

ასევე, გექნებათ წვდომა ვერიფიკაციის სერვერთან, რომელიც მიიღებს შეტყობინებისა და ხელმოწერის წყვილს და გიპასუხებთ, შეესაბამება თუ არა ხელმოწერა შეტყობინებას.

ქსელთან მუშაობის ნაწილი (პაკეტების გაგზავნა და მიღება), როგორც წინა დავალებებში, იმპლემენტირებულია.
დასაწყისისთვის შეგიძლიათ შეამოწმოთ, მუშაობს თუ არა სერვერთან დაკავშირების კოდი ფაილი `sample.py`-ის გაშვებით.

#### ტექნიკური დეტალები:

rsa სერვერების ლოკალურად გასაშვებად გამოიყენეთ ბრძანება
```
python3 rsa_signing_server.py 49104 

python3 rsa_verify_server.py 49105
```

თქვენ უნდა შეავსოთ ფაილი `sign.py` (დაწეროთ `get_signature` ფუნქციის იმპლემენტაცია), რომელიც გაიშვება შემდეგი ბრძანებით:
```
python3 sign.py < input.txt
```

ფაილში `input.txt` წერია RSA-ს მოდული და შეტყობინება. 
stdout-ზე უნდა გამოიტანოთ ამ შეტყობინების ხელმოწერა.
